<!-- 

         bysuborbit.xml            orb package documentation             
                                                               Max Neunhoeffer
                                                                  Felix Noeske

         Copyright (C) 2005, Lehrstuhl D für Mathematik, RWTH-Aachen

This chapter explains functionality for enumeration by suborbits.

-->

<Chapter Label="bysuborbit">
<Heading>Orbit enumeration by suborbits</Heading>

The code described in this chapter is quite complicated and one has
to understand quite a lot of theory to use it. The reason for this is
that a lot of preparatory data has to be found and supplied by the user
in order for this code to run at all. Also the situations in which it
can be used are quite special. However, in such a situation, the user
is rewarded with impressive performance.

<P/> The main reference for the theory is <Cite Key="MNW"/>. We briefly
recall the basic setup: Let <M>G</M> be a group acting from the right
on some set <M>X</M>. Let <M>k</M> be a natural number, set 
<M>X_{{k+1}} := X</M>, and let
<Display> U_1 &lt; U_2 &lt; \cdots &lt; U_k &lt; U_{{k+1}} = G </Display>
be a chain of <Q>helper</Q> subgroups. Further, for <M>1 \le i \le k</M>
let <M>X_i</M> be a <M>U_i</M> set and let <M>\pi_i : X_{{i+1}} \to X_i</M>
be a homomorphism of <M>U_i</M>-sets.

<P/> This chapter starts with a section about the main orbit enumeration
function and the corresponding preparation functions. It then proceeds
with a section on the used data structures, which will necessarily be
rather technical. Finally, the chapter concludes with a section
on higher level data structures like lists of orbit-by-suborbit
objects and their administration. Note that there are quite a few
examples in Chapter <Ref Chap="examples"/>.

<Section>
<Heading><C>OrbitBySuborbits</C> and its resulting objects</Heading>

<ManSection>
<Func Name="OrbitBySuborbit" Arg="setup, p, j, l, i, percentage"/>
<Returns> an orbit-by-suborbit object </Returns>
<Description>
    This is the main function in the whole business. All notations
    from the beginning of this Chapter <Ref Chap="bysuborbit"/> remain
    in place. The argument <A>setup</A>
    must be a setup record lying in the filter 
    <Ref Filt="IsOrbitBySuborbitSetup"/> described in detail in 
    Section <Ref Sect="obsodatastrucs"/> and produced for example by
    <Ref Func="OrbitBySuborbitBootstrapForVectors"/> or
    <Ref Func="OrbitBySuborbitBootstrapForLines"/> described below.
    In particular, it contains all the generators for <M>G</M> and the
    helper subgroups acting on the various sets. The argument <A>p</A>
    must be the starting point of the orbit. Note that the function
    possibly does not take <A>p</A> itself as starting point but rather
    its <M>U_k</M>-minimalisation, which is a point in the same 
    <M>U_k</M>-orbit as <A>p</A>. This information is important
    for the resulting stabiliser and words representing the 
    <M>U_k</M>-suborbits.
    <P/>
    The integers <A>j</A>, <A>l</A>, and <A>i</A>, for which
    <M>k+1 \ge <A>j</A> \ge <A>l</A> &gt; <A>i</A> \ge 1</M> must hold,
    determine the running mode. <A>j</A> indicates in which set <M>X_j</M>
    the point <A>p</A> lies and thus in which set the orbit enumeration
    takes place, with <M>j=k+1</M> indicating the original set <M>X</M>. 
    The value <A>l</A> indicates which group to use for orbit enumeration.
    So the result will be a <M>U_l</M> orbit, with <M><A>l</A>=<A>k</A>+1</M>
    indicating a <M>G</M>-orbit. Finally, the value <A>i</A> indicates
    which group to use for the <Q>by suborbit</Q> part, that is, the orbit
    will be enumerated <Q>by <M>U_{<A>i</A>}</M>-orbits</Q>. Note that
    nearly all possible combinations of these parameters actually occur,
    because this function is also used in the <Q>on-the-fly</Q> 
    precomputation happening behind the scenes. The most common usage
    of this function for the user is <M><A>j</A>=<A>l</A>=<A>k</A>+1</M>
    and <M><A>i</A>=k</M>.
    <P/>
    Finally, the integer <A>percentage</A> says, how much of the full
    orbit should be enumerated, the value is in percent, thus <M>100</M>
    means the full orbit. Usually, only values greater than <M>50</M>
    are sensible, because one can only prove the size of the orbit
    after enumerating at least half of it.
    <P/>
    The result is an <Q>orbit-by-suborbit</Q> object. For such an object
    in particular the operations <Ref Meth="Size"/>, <Ref Oper="Seed"/>,
    <Ref Oper="SuborbitsDb"/>,
    <Ref Oper="WordsToSuborbits"/>, <Ref Oper="Memory"/>,
    <Ref Meth="Stabilizer" Label="obso"/>, and 
    <Ref Oper="Seed"/> are defined, see below.
</Description>
</ManSection>

<ManSection>
<Meth Name="Size" Arg="orb"/>
<Returns> an integer </Returns>
<Description>
Returns the number of points in the orbit-by-suborbit <A>orb</A>.
</Description>
</ManSection>

<ManSection>
<Meth Name="Seed" Arg="orb"/>
<Returns> a point in the orbit </Returns>
<Description>
Returns the starting point of the orbit-by-suborbit <A>orb</A>. It is
the <M>U_i</M>-minimalisation of the starting point given to
<Ref Func="OrbitBySuborbit"/>.
</Description>
</ManSection>

<ManSection>
<Oper Name="SuborbitsDb" Arg="orb"/>
<Returns> a database of suborbits </Returns>
<Description>
Returns the data base of suborbits of the orbit-by-suborbit object
<A>orb</A>. In particular, such a database object has methods
for the operations
<Ref Oper="Memory"/>, <Ref Oper="TotalLength"/>, and
<Ref Oper="Representatives"/>. For descriptions see below.
</Description>
</ManSection>

<ManSection>
<Oper Name="WordsToSuborbits" Arg="orb"/>
<Returns> a list of words </Returns>
<Description>
Returns a list of words in the groups <M>U_*</M> reaching each of the
suborbits in the orbit-by-suborbit <A>orb</A>. Here a word is
a list of integers. Positive numbers index generators in following
numbering: The first few numbers are numbers of generators of <M>U_1</M>
the next few adjacent numbers index the generators of <M>U_2</M> and
so on until the generators of <M>G</M> in the end. Negative numbers
indicate the corresponding inverses of these generators.
<P/>
Note that <Ref Func="OrbitBySuborbit"/> takes the <M>U_i</M>-minimalisation
of the starting point as its starting point and the words here are all
relative to this new starting point.
</Description>
</ManSection>

<ManSection>
<Oper Name="Memory" Arg="ob"/>
<Returns> an integer or a list of two integers </Returns>
<Description>
Returns the amount of memory needed by the object <A>ob</A>, which can
be either an orbit-by-suborbit object, a suborbit database object,
or an object in the filter <Ref Filt="IsOrbitBySuborbitSetup"/>.
The amount of memory used is given in bytes. Note that this includes
all hashes, databases, and preparatory data of substantial size.
For orbit-by-suborbits two numbers are returned, the first being the
amount of memory needed for this orbit and the second being the
amount of memory needed for the precalculation data that is stored
in the setup object.
</Description>
</ManSection>

<ManSection>
<Meth Name="Stabilizer" Arg="orb" Label="obso"/>
<Returns> a permutation group </Returns>
<Description>
Returns the stabiliser of the starting point of the orbit-by-suborbit
in <A>orb</A> in form of a permutation group, using the given
faithful permutation representation in the setup record.
<P/>
Note that <Ref Func="OrbitBySuborbit"/> takes the <M>U_i</M>-minimalisation
of the starting point as its starting point and the stabiliser returned
here is the one of this new starting point.
</Description>
</ManSection>

<ManSection>
<Oper Name="StabWords" Arg="orb"/>
<Returns> a list of words </Returns>
<Description>
Returns generators for the stabiliser of the starting point of the 
orbit-by-suborbit
in <A>orb</A> in form of words as described with the operation <Ref
Oper="WordsToSuborbits"/>. Note again that <Ref Func="OrbitBySuborbit"/>
takes the <M>U_i</M>-minimalisation of the starting point as its
starting point and the stabiliser returned here is the one of this new
starting point.
</Description>
</ManSection>

The following operations apply to orbit-by-suborbit database objects:

<ManSection>
<Oper Name="TotalLength" Arg="db"/>
<Returns> an integer </Returns>
<Description>
Returns the total number of points stored in all suborbits in the 
orbit-by-suborbit database <A>db</A>.
</Description>
</ManSection>

<ManSection>
<Oper Name="Representatives" Arg="db"/>
<Returns> a list of points </Returns>
<Description>
Returns a list of representatives of the suborbits stored in the
orbit-by-suborbit database <A>db</A>.
</Description>
</ManSection>

</Section>


<Section>
<Heading>Preparation functions for <Ref Func="OrbitBySuborbit"/></Heading>

<ManSection>
<Func Name="OrbitBySuborbitBootstrapForVectors" 
      Arg="gens, permgens, sizes, codims, opt"/>
  <Returns> a setup record in the filter <Ref Filt="IsOrbitBySuborbitSetup"/>
  </Returns>
<Description>
All notations from the beginning of this Chapter <Ref Chap="bysuborbit"/> 
remain in place.
This function is for the action of matrices on row vectors, so all generators
must be matrices. The set <M>X</M> thus is a row space usually over a 
finite field and the sets <M>X_i</M> are quotient spaces. The matrix
generators for the various groups have to be adjusted with a base change,
such that the canonical projection onto <M>X_i</M> is just to take the
first few entries in a vector, which means, that the submodules divided
out are generated by the last standard basis vectors.
<P/>
The first argument <A>gens</A> must be a list of lists of generators. 
The outer list must have length <M>k+1</M> with entry <M>i</M> being a list 
of matrices generating <M>U_i</M>, given in the action on <M>X=X_{{k+1}}</M>.
The above mentioned base change must have been done. The second
argument <A>permgens</A> must be an analogous list with generator lists
for the <M>U_i</M>, but here we have to have permutation representations.
These permutation representations are used to compute membership and
group orders of stabilisers. The argument <A>sizes</A> must be a list of
length <M>k+1</M> and entry <M>i</M> must be the group order of <M>U_i</M>
(again with <M>U_{{k+1}}</M> being <M>G</M>). Finally, the argument
<A>codims</A> must be a list of length <M>k</M> containing integers
with the <M>i</M>th entry being the codimension of the <M>U_i</M>-invariant
subspace <M>Y_i</M> of <M>X</M> with <M>X_i = X/Y_i</M>. These
codimensions must not decrease for obvious reasons, but some of them
may be equal. The last argument <A>opt</A> is an options record.
See below for possible entries.
<P/>
The function does all necessary steps to fill a setup record
(see <Ref Sect="obsodatastrucs"/>) to be used with 
<Ref Func="OrbitBySuborbit"/>. For details see the code.
<P/>
Currently, the following components in the options record <A>opt</A>
have a meaning:
<List>
<Mark>regvecfachints</Mark>
<Item>If bound it must be a list. In position <M>i</M> for <M>i&gt;1</M>
there may be a list of vectors in the <M>i</M>-th quotient space <M>X_i</M>
that can be used to distinguish the left <M>U_{{i-1}}</M> cosets in
<M>U_i</M>. All vectors in this list are tried and the first one that
actually works is used.
</Item>
<Mark>regvecfullhints</Mark>
<Item>If bound it must be a list. In position <M>i</M> for <M>i&gt;1</M>
there may be a list of vectors in the full space <M>X</M>
that can be used to distinguish the left <M>U_{{i-1}}</M> cosets in
<M>U_i</M>. All vectors in this list are tried and the first one that
actually works is used.
</Item>
</List>
</Description>
</ManSection>
    
<ManSection>
<Func Name="OrbitBySuborbitBootstrapForLines" 
      Arg="gens, permgens, sizes, codims, opt"/>
  <Returns> a setup record in the filter <Ref Filt="IsOrbitBySuborbitSetup"/>
  </Returns>
<Description>
All notations from the beginning of this Chapter <Ref Chap="bysuborbit"/> 
remain in place. This does exactly the same as 
<Ref Func="OrbitBySuborbitBootstrapForVectors"/> except that it handles
the case of matrices acting on one-dimensional subspaces. Those 
one-dimensional subspaces are represented by normalised vectors,
where a vector is normalised if its first non-vanishing entry is equal
to <M>1</M>.
</Description>
</ManSection>
</Section>

<Section Label="obsodatastrucs">
<Heading>Data structures for orbit-by-suborbits</Heading>

The description in this section is necessarily technical. It is meant
more as extended annotations to the source code than as user documentation.
Usually it should not be necessary for the user to know the details
presented here.

The function <Ref Func="OrbitBySuborbit"/> needs an information record
of the following form:

<ManSection>
<Filt Name="IsOrbitBySuborbitSetup" Arg="ob" Type="Category"/>
<Returns> <K>true</K> or <K>false</K> </Returns>
<Description>
Objects in this category are also in <C>IsComponentObjRep</C>. We describe
the components, refering to the setup at the beginning of this
Chapter <Ref Chap="bysuborbit"/>.
<List>
<Mark><C>k</C></Mark>
<Item> The number of helper subgroups.  </Item>
<Mark><C>size</C></Mark>
<Item> A list of length <M>k+1</M> containing the orders of the groups
    <M>U_i</M>, including <M>U_{{k+1}} = G</M>.
</Item>
<Mark><C>index</C></Mark>
<Item> A list of length <M>k</M> with the index <M>[U_i:U_{{i-1}}]</M>
    in position <M>i</M> (<M>U_0 = \{1\}</M>).
</Item>
<Mark><C>els</C></Mark>
<Item> A list of length <M>k+1</M> containing generators of the groups
in their action on various sets. In position <M>i</M> we store all the
generators for all groups acting on <M>X_i</M>, that is for the groups
<M>U_1, \ldots, U_i</M> (where position <M>k+1</M> includes the generators
for <M>G</M>. In each position the generators of all those groups
are concatentated starting with <M>U_1</M> and ending with <M>U_i</M>.
</Item>
<Mark><C>elsinv</C></Mark>
<Item> The inverses of all the elements in the <C>els</C> component in the
same arrangement.
</Item>
<Mark><C>trans</C></Mark>
<Item> A list of length <M>k</M> in which position <M>i</M> contains 
a list of words in the generators for a transversal of <M>U_{{i-1}}</M>
in <M>U_i</M> (with <M>U_0 = 1</M>).
</Item>
<Mark><C>pifunc</C></Mark>
<Item> Projection functions. This is a list of length <M>k+1</M> containing
in position <M>j</M> a list of length <M>j-1</M> containing in position
<M>i</M> a &GAP; function doing the projection <M>X_j \to X_i</M>.
These &GAP; functions take two arguments, namely the point to map
and secondly the value of the <C>pi</C> component at positions
<C>[j][i]</C>. Usually <C>pifunc</C> is just the slicing operator
in &GAP; and <C>pi</C> contains the components to project onto
as a range object.
</Item>
<Mark><C>pi</C></Mark>
<Item> See the description of the <C>pifunc</C> component.
</Item>
<Mark><C>op</C></Mark>
<Item> A list of <M>k+1</M> &GAP; operation functions, each taking a point
<M>p</M> and a generator <M>g</M> in the action given by the index and 
returning <M>pg</M>.
</Item>
<Mark><C>info</C></Mark>
<Item> 
</Item>
<Mark><C>cosetrecog</C></Mark>
<Item> 
</Item>
<Mark><C>cosetinfo</C></Mark>
<Item> 
</Item>
<Mark><C>suborbnr</C></Mark>
<Item> 
</Item>
<Mark><C>sumstabl</C></Mark>
<Item> 
</Item>
<Mark><C>permgens</C></Mark>
<Item> 
</Item>
<Mark><C>permgensinv</C></Mark>
<Item> 
</Item>
<Mark><C>sample</C></Mark>
<Item> 
</Item>
<Mark><C>stabchainrandom</C></Mark>
<Item> 
</Item>
<Mark><C>wordhash</C></Mark>
<Item> 
</Item>
<Mark><C>wordcache</C></Mark>
<Item> 
</Item>
<Mark><C>hashlen</C></Mark>
<Item> 
</Item>
<Mark><C>staborblenlimit</C></Mark>
<Item> 
</Item>
</List>
</Description>
</ManSection>

</Section>

<Section>
<Heading>Lists of orbit-by-suborbit objects</Heading>

</Section>

<!-- ############################################################ -->

</Chapter>
