<!-- 

         basic.xml            orb package documentation             
                                                               Max Neunhoeffer
                                                                  Felix Noeske

         Copyright (C) 2005, Lehrstuhl D für Mathematik, RWTH-Aachen

This chapter explains functionality for basic orbit enumerations.

-->

<Chapter Label="basic">
<Heading>Basic orbit enumeration</Heading>

This package contains a new implementation of the standard orbit enumeration
algorithm. The design principles for this implementation have been:

<List>
    <Item>Allow partial orbit enumeration and later continuation.
    </Item>
    <Item>Consequently use hashing techniques.</Item>
    <Item>Implement stabiliser calculation and Schreier transversals
        on demand.</Item>
    <Item>Allow for searching in orbits during orbit enumeration.</Item>
</List>

Some of these design principles made it necessary to change the user
interface in comparison to the standard &GAP; one.

<Section>
<Heading>Enumerating orbits</Heading>

The enumeration of an orbit works in at least two stages: First an 
orbit object is created with all the necessary information to describe
the orbit. Then the actual enumeration is started. The latter stage
can be repeated as many times as needed in the case that the orbit
enumeration stopped for some reason before the orbit was enumerated
completely. See below for conditions under which this happens.

<P/> 
For orbit object creation there is the following function:

<ManSection>
<Func Name="Orb" Arg="gens, point, op [, opt]" />
<Returns> An orbit object </Returns>
<Description>
    The argument <A>gens</A> is a list of generators of the group acting,
    <A>point</A> is a point in the orbit to be enumerated, <A>op</A> is
    a &GAP; function describing the action of the generators on points
    in the usual way, that is, <C><A>op</A>(p,g)</C> returns the result
    of the action of the element <C>g</C> on the point <C>p</C>. <P/>
    The optional argument <A>opt</A> is a &GAP; record which can contain
    quite a few options changing the orbit enumeration. For a list of
    possible options see Subsection <Ref Subsect="orboptions"/>
    at the end of this section. <P/>
    The function returns an <Q>orbit</Q> object that can later be used
    to enumerate (a part of) the orbit of <A>point</A> under the action
    of the group generated by <A>gens</A>.
</Description>
</ManSection>

The following operation actually starts the orbit enumeration:

<ManSection>
<Oper Name="Enumerate" Arg="orb [,limit]" />
<Returns> The orbit object <A>orb</A> </Returns>
<Description>
    <A>orb</A> must be an orbit object created by <Ref Func="Orb"/>.
    The optional argument <A>limit</A> must be a positive integer meaning
    that the orbit enumeration should stop if <A>limit</A> points have 
    been found, regardless whether the orbit is complete or not. Note
    that the orbit enumeration can be continued by again calling
    the <Ref Oper="Enumerate"/> operation. If the argument <A>limit</A>
    is omitted, the whole orbit is enumerated, unless other options
    lead to prior termination.
</Description>
</ManSection>

To see whether an orbit is closed you can use the following filter:

<ManSection>
<Filt Name="IsClosed" Arg="orb" />
<Returns> <K>true</K> or <K>false</K> </Returns>
<Description>
    The result indicates, whether the orbit <A>orb</A> is already
    complete or not.
</Description>
</ManSection>

Here is an example of an orbit enumeration:

<Example><![CDATA[gap> g := GeneratorsOfGroup(MathieuGroup(24)); 
[ (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23), 
  (3,17,10,7,9)(4,13,14,19,5)(8,18,11,12,23)(15,20,22,21,16), 
  (1,24)(2,23)(3,12)(4,16)(5,18)(6,10)(7,20)(8,14)(9,21)(11,17)
  (13,22)(15,19) 
 ]
gap> o := Orb(g,2,OnPoints);
<open Int-orbit, 1 points>
gap> Enumerate(o,20);
<open Int-orbit, 21 points>
gap> IsClosed(o);
false
gap> Enumerate(o);   
<closed Int-orbit, 24 points>
gap> IsClosed(o);    
true]]></Example>

The orbit object <C>o</C> now behaves like a dense list, the entries
of which are the points in the orbit in the order as they were found
during the orbit enumeration. So you can ask the orbit for its length,
access entries, and ask, whether a given point lies in the orbit or not.
Due to the hashing techniques used such lookups are quite fast, they
usually only use a constant time regardless of the length of the orbit!

<Example><![CDATA[gap> Length(o);
24
gap> o[1];
2
gap> o[2];
3
gap> o{[3..5]};
[ 23, 4, 17 ]
gap> 17 in o;
true
gap> Position(o,17);
5]]></Example>

In particular, one can express the action of a given group element
in the group generated by the generators given in the <C>Orb</C> command
on this orbit as a permutation:

<ManSection>
<Oper Name="ActionOnOrbit" Arg="orb, grpel"/>
<Returns> A permutation or <K>fail</K> </Returns>
<Description>
    <A>orb</A> must be an orbit object and <A>grpel</A> a group element
    acting on the orbit. This operation calculates the action of
    <A>grpel</A> on <A>orb</A> as a &GAP; permutation, where the
    numbering of the points is in the same order as the points have
    been found in the orbit. Note that this operation is particularly
    fast if the orbit is an orbit of a permutation group acting on
    positive integers or if you used the option <C>storenumbers</C>
    described in Subsection <Ref Subsect="orboptions"/>.
</Description>
</ManSection>

<Subsection Label="orboptions">
    <Heading>Options for orbits</Heading>

<List>
    <Mark>hashlen</Mark>
    <Item></Item>
    <Mark>report</Mark>
    <Item></Item>
    <Mark>storenumbers</Mark>
    <Item></Item>
    <Mark>schreier</Mark>
    <Item></Item>
    <Mark>permgens</Mark>
    <Item></Item>
    <Mark>permbase</Mark>
    <Item></Item>
    <Mark>stab</Mark>
    <Item></Item>
    <Mark>matgens</Mark>
    <Item></Item>
    <Mark>onlystab</Mark>
    <Item></Item>
    <Mark>grpsizebound</Mark>
    <Item></Item>
    <Mark>orbsizebound</Mark>
    <Item></Item>
    <Mark>stabsizebound</Mark>
    <Item></Item>
    <Mark>lookingfor</Mark>
    <Item></Item>
    <Mark>stabchainrandom</Mark>
    <Item></Item>
</List>

</Subsection>

</Section>


<!-- ############################################################ -->

</Chapter>
