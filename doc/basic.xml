<!-- 

         basic.xml            orb package documentation             
                                                               Max Neunhoeffer
                                                                  Felix Noeske

         Copyright (C) 2005, Lehrstuhl D für Mathematik, RWTH-Aachen

This chapter explains functionality for basic orbit enumerations.

-->

<Chapter Label="basic">
<Heading>Basic orbit enumeration</Heading>

This package contains a new implementation of the standard orbit enumeration
algorithm. The design principles for this implementation have been:

<List>
    <Item>Allow partial orbit enumeration and later continuation.
    </Item>
    <Item>Consequently use hashing techniques.</Item>
    <Item>Implement stabiliser calculation and Schreier transversals
        on demand.</Item>
    <Item>Allow for searching in orbits during orbit enumeration.</Item>
</List>

Some of these design principles made it necessary to change the user
interface in comparison to the standard &GAP; one.

<Section>
<Heading>Enumerating orbits</Heading>

The enumeration of an orbit works in at least two stages: First an 
orbit object is created with all the necessary information to describe
the orbit. Then the actual enumeration is started. The latter stage
can be repeated as many times as needed in the case that the orbit
enumeration stopped for some reason before the orbit was enumerated
completely. See below for conditions under which this happens.

<P/> 
For orbit object creation there is the following function:

<ManSection>
<Func Name="Orb" Arg="gens, point, op [, opt]" />
<Returns> An orbit object </Returns>
<Description>
    The argument <A>gens</A> is a list of generators of the group acting,
    <A>point</A> is a point in the orbit to be enumerated, <A>op</A> is
    a &GAP; function describing the action of the generators on points
    in the usual way, that is, <C><A>op</A>(p,g)</C> returns the result
    of the action of the element <C>g</C> on the point <C>p</C>. <P/>
    The optional argument <A>opt</A> is a &GAP; record which can contain
    quite a few options changing the orbit enumeration. For a list of
    possible options see Subsection <Ref Subsect="orboptions"/>
    at the end of this section. <P/>
    The function returns an <Q>orbit</Q> object that can later be used
    to enumerate (a part of) the orbit of <A>point</A> under the action
    of the group generated by <A>gens</A>.
</Description>
</ManSection>

The following operation actually starts the orbit enumeration:

<ManSection>
<Oper Name="Enumerate" Arg="orb [,limit]" />
<Returns> The orbit object <A>orb</A> </Returns>
<Description>
    <A>orb</A> must be an orbit object created by <Ref Func="Orb"/>.
    The optional argument <A>limit</A> must be a positive integer meaning
    that the orbit enumeration should stop if <A>limit</A> points have 
    been found, regardless whether the orbit is complete or not. Note
    that the orbit enumeration can be continued by again calling
    the <Ref Oper="Enumerate"/> operation. If the argument <A>limit</A>
    is omitted, the whole orbit is enumerated, unless other options
    lead to prior termination.
</Description>
</ManSection>

To see whether an orbit is closed you can use the following filter:

<ManSection>
<Filt Name="IsClosed" Arg="orb" />
<Returns> <K>true</K> or <K>false</K> </Returns>
<Description>
    The result indicates, whether the orbit <A>orb</A> is already
    complete or not.
</Description>
</ManSection>

Here is an example of an orbit enumeration:

<Example><![CDATA[gap> g := GeneratorsOfGroup(MathieuGroup(24)); 
[ (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23), 
  (3,17,10,7,9)(4,13,14,19,5)(8,18,11,12,23)(15,20,22,21,16), 
  (1,24)(2,23)(3,12)(4,16)(5,18)(6,10)(7,20)(8,14)(9,21)(11,17)
  (13,22)(15,19) 
 ]
gap> o := Orb(g,2,OnPoints);
<open Int-orbit, 1 points>
gap> Enumerate(o,20);
<open Int-orbit, 21 points>
gap> IsClosed(o);
false
gap> Enumerate(o);   
<closed Int-orbit, 24 points>
gap> IsClosed(o);    
true]]></Example>

The orbit object <C>o</C> now behaves like a dense list, the entries
of which are the points in the orbit in the order as they were found
during the orbit enumeration. So you can ask the orbit for its length,
access entries, and ask, whether a given point lies in the orbit or not.
Due to the hashing techniques used such lookups are quite fast, they
usually only use a constant time regardless of the length of the orbit!

<Example><![CDATA[gap> Length(o);
24
gap> o[1];
2
gap> o[2];
3
gap> o{[3..5]};
[ 23, 4, 17 ]
gap> 17 in o;
true
gap> Position(o,17);
5]]></Example>

In particular, one can express the action of a given group element
in the group generated by the generators given in the <C>Orb</C> command
on this orbit as a permutation:

<ManSection>
<Oper Name="ActionOnOrbit" Arg="orb, grpel"/>
<Returns> A permutation or <K>fail</K> </Returns>
<Description>
    <A>orb</A> must be an orbit object and <A>grpel</A> a group element
    acting on the orbit. This operation calculates the action of
    <A>grpel</A> on <A>orb</A> as a &GAP; permutation, where the
    numbering of the points is in the same order as the points have
    been found in the orbit. Note that this operation is particularly
    fast if the orbit is an orbit of a permutation group acting on
    positive integers or if you used the option <C>storenumbers</C>
    described in Subsection <Ref Subsect="orboptions"/>.
</Description>
</ManSection>

<Subsection Label="orboptions">
    <Heading>Options for orbits</Heading>

The optional fourth argument <A>opt</A> of the function <Ref Func="Orb"/>
is a &GAP; record and its components change the behaviour of the orbit
enumeration. In this subsection we explain the use of the components
of this options record. All components are themselves optional. For
every component we also describe the possible values in the following
list:

<List>
<Mark><C>hashlen</C></Mark>
<Item>Possible values are positive integers. This component determines
the initial size of the hash used for the orbit enumeration. The
default value is <M>10000</M>. If the hash table turns out not to
be large enough, it is automatically increased by a factor of two
during the calculation. Although this process is quite fast it still
improves performance to give a sensible hash size in advance. </Item>
<Mark><C>report</C></Mark>
<Item>Possible values are non-negative integers. This value asks for
a status report whenever the orbit enumeration has applied all generators
to <C>opt.report</C> points. A value of <M>0</M>, which is the default,
switches off this report. In each report, the total number of points
already found are given.</Item>
<Mark><C>storenumbers</C></Mark>
<Item>This boolean flag decides, whether the positions of points in the
orbit are stored in the hash. The memory requirement for this is one
machine word (<M>4</M> or <M>8</M> bytes depending on the architecture)
per point in the orbit. If you just need the orbit itself this is not
necessary. If you however want to find the position of a point in the 
orbit efficiently after enumeration, then you should switch this on.
That is, the operation <C>&bslash;in</C> is always fast, but
<C>Position(<A>orb</A>, <A>point</A>)</C> is only fast if
<C>opt.storenumbers</C> was set to <K>true</K> or the orbit is
<Q>permutations acting on positive integers</Q>. In the latter case
this flag is ignored.</Item>
<Mark><C>schreier</C></Mark>
<Item>This boolean flag decides, whether a Schreier tree is stored
together with the orbit. A Schreier tree just stores for each point,
which generator was applied to which other point in the orbit to get it.
Thus, having the Schreier tree enables the usage of
the operations <Ref Oper="TraceSchreierTreeForward"/> and
<Ref Oper="TraceSchreierTreeBack"/>. A Schreier tree needs two additional
machine words of memory per point in the orbit. The <C>opt.schreier</C>
flag is automatically set when a stabiliser is computed during 
orbit enumeration (see components <C>opt.permgens</C> and
<C>opt.matgens</C>).</Item>
<Mark><C>permgens</C></Mark>
<Item>If this component is set, it must be set to a list of permutations,
that represent the same group as the generators used to define the orbit.
This permutation representation is then used to calculate the stabiliser
of the starting point. After the orbit enumeration is complete, you can
call <C>Stabilizer(<A>orb</A>)</C> with <A>orb</A> being the orbit object
and get the stabiliser as a permutation group. The stabiliser is also
stored in the <C>stab</C> component of the orbit object. Furthermore,
the size of the stabiliser is stored in the <C>stabsize</C> component
of the orbit object and the component <C>stabwords</C> contains the 
stabiliser generators as words in the original group generators. Access
these words with <C>StabWords(orb)</C>. Here,
a word is a list of integers, where positive integers are numbers of 
generators and a negative integer <M>i</M> indicates the inverse of
the generator with number <M>-i</M>. In this way, complete information
about the stabiliser can be derived from the orbit object. </Item>
<Mark><C>permbase</C></Mark>
<Item>This component is used to tell the orbit enumerator that a
certain list of points is a base of the permutation representation
given in the <C>opt.permgens</C> component. This information is
often available beforehand and can drastically speed up the calculation
of Schreier generators, especially for the common case that they are
trivial. The value is just a list of integers.</Item>
<Mark><C>stabchainrandom</C></Mark>
<Item>This value can be <K>false</K> or a positive integer between <M>1</M> 
and <M>1000</M>. If <C>opt.permgens</C> is given, an integer value is
used to set the <C>random</C> option when calculating a stabiliser
chain to compute the size of the group generated by the Schreier
generators. Although this size computation can be speeded up
considerably, the user should be aware that this triggers
a Monte Carlo algorithm that can produce wrong results with a
certain error probability. A verification of the obtained
results is advisable. </Item>
<Mark><C>stab</C></Mark>
<Item>This component is used to tell the orbit enumerator that 
a subgroup of the stabiliser of the starting point is already known.
Store a subgroup of the group generated by the permutations in
<C>opt.permgens</C> stabilising the starting point into this component.</Item>
<Mark><C>matgens</C></Mark>
<Item>This is not yet implemented. It will allow for stabiliser
computations in matrix groups.</Item>
<Mark><C>onlystab</C></Mark>
<Item>If this boolean flag is set to <K>true</K> then the orbit enumeration
stops once the stabiliser is completely determined. Note that this can
only be known, if a bound for the group size is given in the
<C>opt.grpsizebound</C> option and when more than half of the
orbit is already found, or when <C>opt.stabsizebound</C> is given.</Item>
<Mark><C>grpsizebound</C></Mark>
<Item>Possible values for this component are positive integers. By setting
this value one can help the orbit enumeration to complete earlier. The
given number must be an upper bound for the order of the group. If the
exact group order is given and the stabiliser is calculated during the
orbit enumeration (see component <C>permgens</C>, then the orbit
enumeration can stop as soon as the orbit is found completely and the
stabiliser is complete, which is usually much earlier than after
all generator are applied to all points in the orbit.</Item>
<Mark><C>orbsizebound</C></Mark>
<Item>Possible values for this component are positive integers. The
given number must be an upper bound for the orbit length. Giving this
number helps the orbit enumeration to stop earlier, when the orbit
is found completely.</Item>
<Mark><C>stabsizebound</C></Mark>
<Item>Possible values for this component are positive integers. The 
given number must be an upper bound for the size of the stabiliser. Giving
this number helps the orbit enumeration to stop earlier, when also
<C>opt.orbsizebound</C> or <C>opt.grpsizebound</C> are given or when
<C>opt.onlystab</C> is set.</Item>
<Mark><C>lookingfor</C></Mark>
<Item>This component is used to search for something in the orbit. The
idea is that the orbit enumeration is stopped when some condition is 
met. This condition can be specified with a great flexibility. The first
way is to store a list of points into <C>orb.lookingfor</C>. In that 
case the orbit enumeration stops, when a point is found that is in
that list. A second possiblity is to store a hash table object
into <C>orb.lookingfor</C>. Then every newly found point in the
orbit is looked up in that hash table and the orbit enumeration
stops as soon as a point is found that is also in the hash table.
The third possibility is functional: You can store a &GAP; function
into <C>opt.lookingfor</C> which is called for every newly found
point in the orbit. This function has to return <K>false</K> or <K>true</K> 
and in the latter case the orbit enumeration is stopped.
<P/>
Whenever the orbit enumeration is stopped the component <C>found</C>
is set to the number of the found point in the orbit. Access this
information using <C>PositionOfFound(orb)</C>.
</Item>
</List>
For some examples using these options see Chaper <Ref Chap="examples"/>.
</Subsection>

<ManSection>
<Oper Name="TraceSchreierTreeForward" Arg="orb, nr"/>
<Returns> A word in the generators </Returns>
<Description>
<A>orb</A> must be an orbit object with a Schreier tree, that is, the
option <C>schreier</C> must have been set during creation, and <A>nr</A>
must be the number of a point in the orbit. This operation traces the
Schreier tree and returns a word in the generators that maps the starting
point to the point with number <A>nr</A>. Here,
a word is a list of integers, where positive integers are numbers of 
generators and a negative integer <M>i</M> indicates the inverse of
the generator with number <M>-i</M>. 
</Description>
</ManSection>

<ManSection>
<Oper Name="TraceSchreierTreeBack" Arg="orb, nr"/>
<Returns> A word in the generators </Returns>
<Description>
<A>orb</A> must be an orbit object with a Schreier tree, that is, the
option <C>schreier</C> must have been set during creation, and <A>nr</A>
must be the number of a point in the orbit. This operation traces the
Schreier tree and returns a word in the generators that maps the 
point with number <A>nr</A> to the starting point. As above,
a word is here a list of integers, where positive integers are numbers of 
generators and a negative integer <M>i</M> indicates the inverse of
the generator with number <M>-i</M>. 
</Description>
</ManSection>

</Section>


<!-- ############################################################ -->

</Chapter>
