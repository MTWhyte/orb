<!-- 

  examples.xml            orb package documentation             Max Neunhoeffer
                                                                   Felix Noeske

         Copyright (C) 2005, Lehrstuhl D für Mathematik, RWTH-Aachen

This chapter gives examples for the usage of this package.

-->

<Chapter Label="examples">
<Heading>Examples</Heading>



Currently we have one major example, which however illustrates a lot
of the tools which are available in the <Package>orb</Package> package
as well as in some other packages. 
<P/>

???
<P/>

???
What do we have to do? (See <Cite Key="MNW"/>)
Comment: in general quite difficult, have to try things.
<P/>




In Section <Ref Sect="Borbit"/>
we present as an extended worked example how to
enumerate the smallest non-trivial orbit of the 
sporadic simple Baby monster group.

<!-- ==================================================================== -->

<Section Label="Borbit">
<Heading>Enumerating the smallest Baby monster orbit</Heading>

In this section we show in detail how to enumerate the smallest 
non-trivial orbit of the sporadic simple Baby monster group <M>B</M>. 
The associated one-point stabilisers are the largest 
maximal subgroups <M>E\cong 2.^2E_6(2).2</M> of <M>B</M>.
Hence <M>E</M> is a bicyclic extension 
of the twisted Lie type group <M>^2E_6(2)</M>,
and has index <M>[B\colon E]=13\,571\,955\,000\sim 1.4\cdot 10^{10}</M>,
see <Cite Key="CCN85"/> or the <Package>CTblLib</Package> package.
<P/>

We present a log of a &GAP; session with explanations in between, 
where larger pieces of output have been replaced by <C>...</C>.
We begin by loading the packages we are using in the sequel, where the
<Package>orb</Package> package automatically invokes the
<Package>io</Package> package, and the <Package>chop</Package> package
automatically invokes the <Package>cvec</Package> package.

<!-- ??? How official are these packages? -->

<Log><![CDATA[
gap> LoadPackage("orb");;
...
gap> LoadPackage("atlasrep");;
...
gap> LoadPackage("chop");;
...
gap> LoadPackage("genss");;
... ]]> 
</Log>

We first try to find a matrix representation of <M>B</M>
such that the <M>B</M>-orbit we look for is realised as 
a set of vectors in the underlying vectors space. 
The smallest faithful representation 
of <M>B</M> over the field GF(2), by <Cite Key="Jansen"/> 
having dimension 4370, springs to mind.
Explicit matrices in terms of standard generators
in the sense of <Cite Key="Wil96"/>
are available in <Cite Key="AGR"/>, 
and are accessibe through the <Package>atlasrep</Package> package.
Moreover, we find generators of <M>E</M> by applying a straight line program,
also available in the <Package>atlasrep</Package> package,
expressing generators of <M>E</M> in terms of the generators of <M>B</M>. 

<Log><![CDATA[
gap> gens := AtlasGenerators("B",1).generators;
[ <an immutable 4370x4370 matrix over GF2>, 
  <an immutable 4370x4370 matrix over GF2> ]
gap> bgens := List(gens,CMat);
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ] 
gap> slpbtoe := AtlasStraightLineProgram("B",1).program;;
gap> egens := ResultOfStraightLineProgram(slpbtoe,bgens);
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ] ]]>
</Log>

We look for a non-zero vector being fixed by both generators of <M>E</M>.
It turns out that the latter have a common fixed space of dimension 1.
Then, since <M>E</M> is a maximal subgroup,
the stabiliser in <M>B</M> of the non-zero vector <M>v</M> 
in that fixed space coincides with <M>E</M>.

<Log><![CDATA[
gap> x := egens[1]-One(egens[1]);;
gap> nsx := NullspaceMat(x);
<immutable cmat 2202x4370 over GF(2,1)>
gap> y := egens[2]-One(egens[2]);;
gap> y := nsx * y;;
gap> nsy := NullspaceMat(y);
<immutable cmat 1x2202 over GF(2,1)>
gap> v := nsy[1]*nsx;
<immutable cvec over GF(2,1) of length 4370> ]]>
</Log>

Storing eight elements of GF(2) into 1 byte, to store a vector of length 
4370 needs 547 bytes, hence to store the full <M>B</M>-orbit of <M>v</M> 
we need 
<M>547\cdot [B\colon E]=7\,423\,859\,385\,000\sim 7.4\cdot 10^{12}</M> bytes.
Hence we try to find helper subgroups suitable to achieve a saving
factor of <M>\sim 10^4</M>, i. e. allowing to store only one out of
<M>\sim 10^4</M> vectors. To this end, we look for a pair 
<M>U_1<![CDATA[<]]>U_2</M> of helper subgroups 
such that <M>|U_2|\sim 10^5</M>, where we take 
into account that typically the overall saving factor achieved is 
somewhat smaller than the order of the largest helper subgroup.
<P/>

<!-- ====================================================================

etbl:=2E6(2); e3tbl:=2E6(2).3; e2tbl:=2E6(2).2;
fi22 has 24 fusions into e, forming 3 orbits under TblAut(fi22tbl) x id,
parametrized representatives reps being
[ 1, 2, 3, 4, 5, 7, 6, 7, [ 11, 12, 13 ], 15, [ 16, 17, 18 ], 19, 20, 23,
  24, 27, 30, 26, 25, 29, 32, 31, 28, 31, 32, 34, [ 39, 40, 41 ],
  [ 39, 40, 41 ], [ 43, 44, 45 ], 49, 51, 52, 52, 53, 54, 55, 56,
  [ 67, 68, 69 ], [ 64, 65, 66 ], [ 64, 65, 66 ], 70, [ 75, 76 ],
  [ 76, 77 ], 74, [ 78, 79, 80 ], 71, 73, [ 75, 76, 77 ], 83, 83, 85, 87,
  [ 91, 92, 93 ], [ 91, 92, 93 ], 99, 100, 101, 102, 106, 108, 109, 110,
  [ 114, 115, 116 ], [ 114, 115, 116 ], 122 ]
classes [11..13] = 4DEF fuse in e3, 
hence these fusions reflect the 3 conjugacy classes of maximal fi22 in e

composed with fus_e_e2 the above reps yields 2 fusions, 
the second and third yielding the same one,
reflecting the 2 conjugacy classes of maximal fi22 in e2,
fus_fi22_e2:=
[ [ 1, 2, 3, 4, 5, 7, 6, 7, 11, 14, 15, 17, 18, 21, 22, 25, 28, 24, 23, 27,
      30, 29, 26, 29, 30, 32, 37, 37, 40, 44, 46, 47, 47, 48, 49, 50, 50,
      59, 57, 57, 61, 67, 67, 65, 68, 62, 64, 66, 72, 72, 74, 76, 79, 79,
      85, 85, 86, 87, 90, 92, 93, 93, 97, 97, 103 ],
  [ 1, 2, 3, 4, 5, 7, 6, 7, 12, 14, 16, 17, 18, 21, 22, 25, 28, 24, 23, 27,
      30, 29, 26, 29, 30, 32, 38, 38, 41, 44, 46, 47, 47, 48, 49, 50, 50,
      60, 58, 58, 61, 66, 67, 65, 69, 62, 64, 67, 72, 72, 74, 76, 80, 80,
      85, 85, 86, 87, 90, 92, 93, 93, 98, 98, 103 ] ];

the first of the above lifts to the unique fusion of fi22 in 2e2,
the second lifts to one of the two possible fusions of 2fi22 in 2e2,
hence we have

- a unique conjugacy class of fi22 in 2e2, 
being contained in a maximal subgroup 2 x fi22 of 2e
and in a maximal subgroup 2 x fi22:2 of 2e2, and

- a unique conjugacy class of maximal subgroups 2.fi22 in 2e2,
splitting into 2 conjugacy classes of maximal subgroups of 2e

fus_fi22_2e2:=
[ 1, 4, 5, 7, 8, 12, 10, 12, 18, 23, 24, 27, 29, 32, 35, 41, 45, 38, 37, 44,
  50, 47, 42, 48, 49, 53, 61, 60, 64, 70, 73, 75, 75, 78, 79, 81, 81, 94,
  91, 91, 98, 107, 107, 103, 109, 99, 102, 105, 114, 114, 119, 122, 126,
  126, 137, 137, 139, 140, 147, 150, 153, 153, 159, 160, 170 ]
fus_2fi22_2e2:=
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 10, 11, 12, 13, 20, 22, 23, 26, 27, 28,
  29, 32, 33, 34, 35, 40, 41, 45, 46, 38, 39, 36, 37, 44, 49, 50, 47, 48,
  42, 43, 47, 48, 49, 50, 53, 54, 62, 62, 66, 70, 70, 73, 74, 75, 76, 75,
  76, 77, 78, 79, 80, 81, 82, 81, 82, 96, 93, 93, 93, 97, 98, 106, 105, 108,
  107, 103, 104, 111, 99, 101, 102, 107, 108, 114, 115, 114, 115, 118, 119,
  122, 123, 128, 128, 136, 137, 136, 137, 138, 139, 140, 141, 146, 147, 150,
  151, 152, 153, 152, 153, 161, 161, 169, 170 ]

conjugacy classes of m12:

elements of order 11 have centralizer 66 in e,
and there are no fusions of m122, or 2xm12, or 3xm12 into e,
hence any m12 has trivial centralizer in e, 
and again since there is no m122, any m12 is self-normalising in e 

in e3 there is a unique conjugacy class of m12 in the unique 
conjugacy class of fi22, and since the normalizer of fi22 
in e3 equals the centralizer, namely 3 x fi22,
the normalizer of m12 in e3 also equals the centralizer, 
and is of shape 3 x m12, implying that the above conjugacy class of m12
in e3 splits into 3 classes in e

hence in e2 there are 2 conjugacy of such m12

     ==================================================================== -->

By <Cite Key="CCN85"/>, and a few computations with subgroup fusions
using the <Package>CTblLib</Package> package,
the derived subgroup <M>E'\cong 2.^2E_6(2)</M> of <M>E</M> turns
out to possess maximal subgroups 
<M>2\times Fi_{22}</M> and <M>2.Fi_{22}</M>, 
where <M>Fi_{22}</M> denotes one of the sporadic simple Fischer groups,
and where the former constitute a unique conjugacy class
with associated normalizers in <M>E</M> of shape 
<M>2\times Fi_{22}.2</M>, while 
the latter consist of two conjugacy classes being self-normalising
and interchanged by <M>E</M>.
<P/>

Now <M>Fi_{22}</M> has a unique conjugacy class of maximal
subgroups <M>M_{12}</M>, where the latter denotes one of 
the sporadic simple Mathieu groups; the subgroups <M>M_{12}</M>
lift to a unique conjugacy class of subgroups <M>M_{12}</M> 
of <M>2.Fi_{22}</M>, which turn out to constitute a conjugacy class 
of subgroups of <M>E</M> different from the subgroups <M>M_{12}</M>
being contained in <M>Fi_{22}</M>. Anyway, we have 
<M>|M_{12}|=95\,040</M>, hence <M>U_2=M_{12}</M> 
seems to be a good candidate for the larger helper subgroup.
In particular, there is a unique conjugacy class of maximal
subgroups <M>L_2(11)</M> of <M>M_{12}</M>, and 
since <M>|L_2(11)|=660</M> and <M>[M_{12}\colon L_2(11)]=144</M>
letting <M>U_1=L_2(11)</M> seems to be a good candidate
for the smaller helper subgroup.
Recall that <M>U_1</M> and <M>U_2</M> are useful helper subgroups
only if we are able to find suitable quotient modules allowing for the
envisaged saving factor.
<P/>

To find <M>U_1</M> and <M>U_2</M>, we first try to find a subgroup 
<M>Fi_{22}</M> or <M>2.Fi_{22}</M> of <M>E</M>.
We start a random search, aiming at finding standard generators
of <M>(2.)Fi_{22}</M>, and we use <C>GeneratorsWithMemory</C>
in order to be able to express the generators found as words
in the generators of <M>E</M>. To accelerate computations
we first construct a small representation of <M>E</M>;
by <Cite Key="Jansen"/> the smallest faithful irreducible 
representation of <M>Fi_{22}</M> over GF(2) has dimension 78,
hence we cannot do better for <M>E</M>; note that the latter is
a representation of <M>\overline{E}:=E/Z(E)\cong {}^2E_6(2).2</M>.

<Log><![CDATA[
gap> m := Module(egens);
<module of dim. 4370 over GF(2)>
gap> SetInfoLevel(InfoChop,2);
gap> r := Chop(m);
...
rec( ischoprecord := true, 
  db := [ <abs. simple module of dim. 78 over GF(2)>, 
          <trivial module of dim. 1 over GF(2)>, 
          <abs. simple module of dim. 1702 over GF(2)>, 
          <abs. simple module of dim. 572 over GF(2)> ], 
  mult := [ 5, 4, 2, 1 ], 
  acs := [ 1, 2, 3, 1, 4, 1, 1, 2, 2, 3, 1, 2 ], 
  module := <reducible module of dim. 4370 over GF(2)> )
gap> egens78 := GeneratorsWithMemory(RepresentingMatrices(r.db[1]));
[ <<immutable cmat 78x78 over GF(2,1)> with mem>, 
  <<immutable cmat 78x78 over GF(2,1)> with mem> ] ]]>
</Log>

Standard generators <M>a,b</M> of <M>(2.)Fi_{22}</M>
are given as follows, see <Cite Key="AGR"/>:
<M>a</M> is an element of the 2A conjugacy class of <M>(2.)Fi_{22}</M>,
where the conjugacy classes are denoted as in <Cite Key="CCN85"/>,
and <M>b</M>, <M>ab</M> and <M>(ab)^4bab(abb)^2</M> have order 13,
11 and 12, respectively. 
The 2A conjugacy class of <M>Fi_{22}</M>
fuses into the 2A conjugacy class of <M>\overline{E}</M>, 
where the latter is obtained as the 11-th power of the
unique conjugacy class consisting of elements of order 22, and 
<M>\overline{E}</M> has only one conjugacy class of elements of order 13. 

<Log><![CDATA[
gap> o := Orb(egens78,StripMemory(egens78[1])^0,OnRight,
>    rec(schreier := true,report := 1000,
>    lookingfor := function(o,x) return Order(x)=22; end));
<open orbit, 1 points with Schreier tree looking for sth.>
gap> Enumerate(o);
<open orbit, 393 points with Schreier tree looking for sth.>
gap> word := TraceSchreierTreeForward(o,o!.found);
[ 1, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2 ]
gap> g2a := Product(egens78{word})^11;
<<immutable cmat 78x78 over GF(2,1)> with mem>
gap> o := Orb(egens78,StripMemory(egens78[1])^0,OnRight,
>    rec(schreier := true,report := 1000,
>    lookingfor := function(o,x) return Order(x)=13; end));
<open orbit, 1 points with Schreier tree looking for sth.>
gap> Enumerate(o);
<open orbit, 144 points with Schreier tree looking for sth.>
gap> word := TraceSchreierTreeForward(o,o!.found);
[ 1, 2, 1, 2, 1, 2, 1, 2, 2 ]
gap> b := Product(egens78{word});
<<immutable cmat 78x78 over GF(2,1)> with mem> ]]>
</Log>

We search through the <M>\overline{E}</M>-conjugates of <C>g2a</C>
until we find a conjugate <M>a</M> together with <M>b</M> 
fulfilling the defining conditions of standard generators of <M>Fi_{22}</M>, 
and moreover fulfilling the relations of the associated presentation 
of <M>Fi_{22}</M> also available in <Cite Key="AGR"/>.
To find random conjugates we use the product replacement algorithm to 
produce random elements of <M>\overline{E}</M> to conjugate <C>g2a</C> with. 
The success probability of this approach is given as follows:
Letting <M>\overline{E'}:=E'/Z(E')\cong {}^2E_6(2)</M>,
out of the <M>|\overline{E'}|/|C_{\overline{E'}}(g2a)|</M> 
conjugates of <C>g2a</C> there are 
<M>|C_{\overline{E'}}(b)|/|C_{\overline{E'}}(Fi_{22})|
=|C_{\overline{E'}}(b)|</M>
elements together with the fixed element <M>b</M> 
giving standard generators of <M>Fi_{22}</M>. 
Since <M>Fi_{22}</M> has two conjugacy classes of elements of order 13, 
and there are three conjugacy classes of subgroups <M>Fi_{22}</M>
of <M>\overline{E'}</M>, the success probability is
<M>6\cdot |C_{\overline{E'}}(g2a)|\cdot 
   |C_{\overline{E'}}(b)|/|\overline{E'}|=2/101745\sim 2\cdot 10^{-5}</M>.

<Log><![CDATA[
gap> pr := ProductReplacer(egens78,rec(maxdepth := 150));
<product replacer nrgens=2 slots=12 scramble=100 maxdepth=150 steps=0 (rattle)>
gap> i := 0;;
gap> repeat
>      i := i + 1;
>      x := Next(pr);
>      a := g2a^x;
>    until IsOne((a*b)^11) and IsOne(((a*b)^4*b*a*b*(a*b*b)^2)^12) and
>      IsOne((a*b^2)^21) and 
>      IsOne(Comm(a,b)^3) and IsOne(Comm(a,b^2)^3) and IsOne(Comm(a,b^3)^3) and
>      IsOne(Comm(a,b^4)^2) and IsOne(Comm(a,b^5)^3) and
>      IsOne(Comm(a,b*a*b^2)^3) and IsOne(Comm(a,b^-1*a*b^-2)^2) and
>      IsOne(Comm(a,b*a*b^5)^2) and IsOne(Comm(a,b^2*a*b^5)^2);
gap> i;
6362 ]]>
</Log>

Indeed, we have been fairly lucky.
Due to a presentation being available we have indeed proved 
that the elements found generate a subgroup <M>Fi_{22}</M>.
If we had not had a presentation at hand, 
we would only have been able to produce elements fulfilling
the defining conditions of standard generators of <M>Fi_{22}</M>,
which hence still could generate a subgroup of another isomorphism type.
In that case, for further checks we can use the following tools:
We try to find a short orbit of vectors, and using a randomized 
Schreier-Sims algorithm gives a lower bound for the order of the group seen. 
However, we can use the action on the orbit to get a homomorphism 
into a permutation group, allowing to prove that the group generated
has <M>Fi_{22}</M> as a quotient.

<Log><![CDATA[
gap> g := Group(a,b);
<matrix group with 2 generators>
gap> S := StabilizerChain(g,rec(TryShortOrbit := 30,OrbitLengthLimit := 5000,
>                               FailInsteadOfError := true));
...
<stabchain size=64561751654400 orblen=3510 layer=1 SchreierDepth=8>
 <stabchain size=18393661440 orblen=2816 layer=2 SchreierDepth=7>
  <stabchain size=6531840 orblen=1680 layer=3 SchreierDepth=7>
   <stabchain size=3888 orblen=243 layer=4 SchreierDepth=5>
    <stabchain size=16 orblen=16 layer=5 SchreierDepth=2>
gap> Size(S)=Size(CharacterTable("Fi22"));
true 
gap> p := Group(ActionOnOrbit(S!.orb,[a,b]));
<permutation group with 2 generators>
gap> DisplayCompositionSeries(p);
G (2 gens, size 64561751654400)
 | Fi(22)
1 (0 gens, size 1) ]]>
</Log>

We now return to our original representation, and check whether 
we possibly have standard generators of <M>(2.)Fi_{22}</M>.

<!-- ??? Comment about SlotUsagePattern. (Max?) -->

<Log><![CDATA[
gap> SetInfoLevel(InfoSLP,2);
gap> slpetofi22 := SLPOfElms([a,b]);
<straight line program>
gap> SlotUsagePattern(slpetofi22);;
gap> fgens := ResultOfStraightLineProgram(slpetofi22,egens);
...
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ]
gap> aa := fgens[1];;
gap> bb := fgens[2];;
gap> IsOne(aa^2);
true
gap> IsOne(bb^13);
true
gap> IsOne((aa*bb)^11);
false 
gap> IsOne((aa*bb)^22);
true ]]>
</Log>

This implies that <M>(aa*bb)^{11}</M> is the non-trivial element
of <M>Z(E)</M>. Hence we adjust the generators accordingly,
and check whether they now fulfill the defining conditions of
standard generators of <M>(2.)Fi_{22}</M> and the relations 
of the associated presentation of <M>(2.)Fi_{22}</M>.

<Log><![CDATA[
gap> a := a * (a*b)^11;;
gap> slpetofi22 := SLPOfElms([a,b]);;
gap> SlotUsagePattern(slpetofi22);; 
gap> fgens := ResultOfStraightLineProgram(slpetofi22,egens);
...
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ]
gap> a := fgens[1];;
gap> b := fgens[2];; 
gap> IsOne(a^2) and IsOne(b^13);
true
gap> IsOne((a*b)^11) and IsOne(((a*b)^4*b*a*b*(a*b*b)^2)^12);
true
gap> IsOne(Comm(a,b)^3) and IsOne(Comm(a,b^2)^3) and IsOne(Comm(a,b^3)^3) and
>    IsOne(Comm(a,b^4)^2) and IsOne(Comm(a,b^5)^3) and
>    IsOne(Comm(a,b*a*b^2)^3) and IsOne(Comm(a,b^-1*a*b^-2)^2) and
>    IsOne(Comm(a,b*a*b^5)^2) and IsOne(Comm(a,b^2*a*b^5)^2);
true
gap> IsOne((a*b^2)^21);
false; ]]>
</Log>

This shows that the elements found indeed generate
a subgroup <M>2.Fi_{22}</M>.
Note that in our random search with a probability of 1/3 
we could also have hit a subgroup <M>(2\times)Fi_{22}</M>.
(This actually happened to us in another run of this example.)
In that case, we deal with the central element
also as described above, and we proceed further entirely similar
to the case worked out here. 
<P/>

Standard generators of <M>U_2=M_{12}</M>
in terms of standard generators of <M>Fi_{22}</M>,
and generators of <M>U_1=L_2(11)</M> 
in terms of standard generators of <M>M_{12}</M>
are accessible in the <Package>atlasrep</Package> package.
The next task is to find good quotients with 
longish orbits for the helper subgroups.

<Log><![CDATA[
gap> slpfi22tom12 := AtlasStraightLineProgram("Fi22",14).program;;
gap> slpm12tol211 := AtlasStraightLineProgram("M12",5).program;;
gap> mgens := ResultOfStraightLineProgram(slpfi22tom12,fgens);
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ]
gap> lgens := ResultOfStraightLineProgram(slpm12tol211,mgens);
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ]
gap> List(mgens,Order);
[ 2, 3 ]
gap> Order(mgens[1]*mgens[2]);
11 ]]>
</Log>

By our construction, <C>mgens</C> generates a subgroup 
<M>(2\times)M_{12}</M>, and the element orders show
that this indeed is a subgroup <M>M_{12}</M>.
We restrict to <M>M_{12}</M> and look for suitable quotient modules;
to this end, we first compute the radical series.

<Log><![CDATA[
gap> m := Module(mgens);
<module of dim. 4370 over GF(2)>
gap> r := Chop(m);
...
gap> rad := RadicalSeries(m,r.db);
...
rec( 
  db := [ <abs. simple module of dim. 44 over GF(2)>, 
          <simple module of dim. 32 over GF(2) splitting field degree 2>, 
          <abs. simple module of dim. 144 over GF(2)>, 
          <abs. simple module of dim. 10 over GF(2)>, 
          <trivial module of dim. 1 over GF(2)> ], 
  module := <reducible module of dim. 4370 over GF(2)>, 
  basis := <immutable cmat 4370x4370 over GF(2,1)>, 
  ibasis := <immutable cmat 4370x4370 over GF(2,1)>, 
  cfposs := 

???
...
  isotypes := [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 
          2, 2, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 ], 
...
  isradicalrecord := true ) ]]>
</Log>

and observe that there are faithful irreducible quotients of dimensions
10, 32, 44, and 144.
pick a summand of dimension 32 in the head,
 
...

... and apply the associated base change to the generators of <M>B</M>.


<Log><![CDATA[
gap> bgens := List(bgens,x->rad.basis*x*rad.ibasis);
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ] 
gap> l := rad.cfposs[1][13];
[ 529 .. 560 ]
gap> Append(l,Difference([1..4370],l));
gap> bgens := List(bgens,x->ORB_PermuteBasisVectors(x,l));
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ]
gap> egens := ResultOfStraightLineProgram(slpbtoe,bgens);;
gap> fgens := ResultOfStraightLineProgram(slpetofi22,egens);;
...
gap> mgens := ResultOfStraightLineProgram(slpfi22tom12,fgens);;
gap> lgens := ResultOfStraightLineProgram(slpm12tol211,mgens);; ]]>
</Log>

We now arrange things for <M>U_1=L_2(11)</M> within the 
32-dimensional quotient module. 

... semisimple ...

... dim 20 = 10 + 10 ...


<Log><![CDATA[
gap> lgens32 := List(lgens,x->ExtractSubMatrix(x,[1..32],[1..32]));
[ <cmat 32x32 over GF(2,1)>, <cmat 32x32 over GF(2,1)> ]
gap> m := Module(lgens32);
<module of dim. 32 over GF(2)>
gap> r := Chop(m);
...
gap> soc := SocleSeries(m,r.db);
rec( issoclerecord := true, 
  db := [ <abs. simple module of dim. 10 over GF(2)>, 
          <simple module of dim. 10 over GF(2) splitting field degree 2>, 
          <trivial module of dim. 1 over GF(2)> ], 
  module := <reducible module of dim. 32 over GF(2)>, 
  basis := <cmat 32x32 over GF(2,1)>, ibasis := <cmat 32x32 over GF(2,1)>, 
  cfposs := [ [ [ 1 .. 10 ], [ 11 .. 20 ], [ 21 .. 30 ], [ 31 ], [ 32 ] ] ], 
  isotypes := [ [ 1, 1, 2, 3, 3 ] ] )
gap> t := ORB_EmbedBaseChangeTopLeft(soc.basis,4370);
<cmat 4370x4370 over GF(2,1)>
gap> ti := t^-1;;
gap> bgens := List(bgens,x->t*x*ti);
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ]
gap> egens := ResultOfStraightLineProgram(slpbtoe,bgens);;
gap> fgens := ResultOfStraightLineProgram(slpetofi22,egens);;
...
gap> mgens := ResultOfStraightLineProgram(slpfi22tom12,fgens);;
gap> lgens := ResultOfStraightLineProgram(slpm12tol211,mgens);; ]]>
</Log>

<P/>
===========================================================================
<P/>
do base changes

We now check that the quotients found are good for our helper
subgroups:

<Log><![CDATA[
gap> guck := List(lgens,x->ExtractSubMatrix(x,[1..20],[1..20]));
[ <cmat 20x20 over GF(2,1)>, <cmat 20x20 over GF(2,1)> ]
gap> OrbitStatisticOnVectorSpace(guck,660,10);
...
gap> guck := List(mgens,x->ExtractSubMatrix(x,[1..32],[1..32]));
[ <cmat 32x32 over GF(2,1)>, <cmat 32x32 over GF(2,1)> ]
gap> OrbitStatisticOnVectorSpace(guck,95040,10);
...]]>
</Log>

Average orbit lengths good...

<P/>

find corresponding permutation action for helper subgroups

<Log><![CDATA[
gap> guck := List(mgens,x->ExtractSubMatrix(x,[1..32],[1..32]));
[ <cmat 32x32 over GF(2,1)>, <cmat 32x32 over GF(2,1)> ]
gap> S := StabilizerChain(Group(guck),rec(TryShortOrbit := 10));
...
<stabchain size=95040 orblen=3960 layer=1 SchreierDepth=7>
 <stabchain size=24 orblen=24 layer=2 SchreierDepth=4>
gap> p := Group(ActionOnOrbit(S!.orb,guck));
<permutation group with 2 generators>
gap> Size(p);
95040
gap> pp := Image(SmallerDegreePermutationRepresentation(p));
<permutation group of size 95040 with 2 generators>
gap> m12 := MathieuGroup(12);;
gap> i := IsomorphismGroups(pp,m12);;
gap> newgens := List(GeneratorsOfGroup(pp),x->ImageElm(i,x));
[ (3,5)(6,9)(8,10)(11,12), (1,2,3)(4,10,6)(5,7,9)(8,11,12) ]
gap> newgensl := ResultOfStraightLineProgram(slpm12tol211,newgens);
[ (1,11)(2,12)(3,5)(4,8)(6,9)(7,10), (1,2,12)(3,10,9)(4,6,11)(5,7,8) ]]]>
</Log>

We could just go on from here, however, sometimes it is useful to save
all the created data to disk...

<Log><![CDATA[
gap> f := IO_File("data.gp","w");;
gap> IO_Pickle(f,"Generators of B in new basis");;
gap> IO_Pickle(f,bgens);;
gap> IO_Pickle(f,"slpbtoe");;
gap> IO_Pickle(f,slpbtoe);;
gap> IO_Pickle(f,"slpetofi22");;
gap> IO_Pickle(f,slpetofi22);;
gap> IO_Pickle(f,"slpfi22tom12");;
gap> IO_Pickle(f,slpfi22tom12);;
gap> IO_Pickle(f,"slpm12tol211");;
gap> IO_Pickle(f,slpm12tol211);;
gap> IO_Pickle(f,"Now all the generators from E to L2(11) as matrices");;
gap> IO_Pickle(f,egens);;
gap> IO_Pickle(f,fgens);;
gap> IO_Pickle(f,mgens);;
gap> IO_Pickle(f,lgens);;
gap> IO_Pickle(f,"Permutation gens for M12 and L2(11)");;
gap> IO_Pickle(f,newgens);;
gap> IO_Pickle(f,newgensl);;
gap> IO_Close(f);
true]]>
</Log>

This can be loaded again in the following way:

<Log><![CDATA[gap> LoadPackage("cvec");;
...
gap> LoadPackage("orb");;
...
gap> f := IO_File("data.gp");
<file fd=4 rbufsize=65536 rpos=1 rdata=0>
gap> IO_Unpickle(f);
"Generators of B in new basis"
gap> bgens := IO_Unpickle(f);    # B
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ]
gap> IO_Unpickle(f);
"slpbtoe"
gap> slpbtoe := IO_Unpickle(f);
<straight line program>
gap> IO_Unpickle(f);
"slpetofi22"
gap> slpetofi22 := IO_Unpickle(f);
<straight line program>
gap> IO_Unpickle(f);
"slpfi22tom12"
gap> slpfi22tom12 := IO_Unpickle(f);
<straight line program>
gap> IO_Unpickle(f);
"slpm12tol211"
gap> slpm12tol211 := IO_Unpickle(f);
<straight line program>
gap> IO_Unpickle(f);
"Now all the generators from E to L2(11) as matrices"
gap> egens := IO_Unpickle(f);    # 2.E6(2).2
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ]
gap> fgens := IO_Unpickle(f);    # Fi22
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ]
gap> mgens := IO_Unpickle(f);    # M12
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ]
gap> lgens := IO_Unpickle(f);    # L2(11)
[ <cmat 4370x4370 over GF(2,1)>, <cmat 4370x4370 over GF(2,1)> ]
gap> IO_Unpickle(f);
"Permutation gens for M12 and L2(11)"
gap> mgensp := IO_Unpickle(f);   # M12 as permutations
[ (3,5)(6,9)(8,10)(11,12), (1,2,3)(4,10,6)(5,7,9)(8,11,12) ]
gap> lgensp := IO_Unpickle(f);   # L2(11) as permutations
[ (1,11)(2,12)(3,5)(4,8)(6,9)(7,10), (1,2,12)(3,10,9)(4,6,11)(5,7,8) ]
gap> IO_Close(f);;]]>
</Log>

Then the orbit enumeration can be done in the following way.
Note that since we did various base changes we have to recreate the fixed 
vector <C>v</C> exactly as above.

<Log>
<![CDATA[gap> a := egens[1]-One(egens[1]);
<cmat 4370x4370 over GF(2,1)>
gap> ns := NullspaceMat(a);
<immutable cmat 2202x4370 over GF(2,1)>
gap> a := egens[2]-One(egens[2]);
<cmat 4370x4370 over GF(2,1)>
gap> a := ns * a;
<cmat 2202x4370 over GF(2,1)>
gap> ns2 := NullspaceMat(a);
<immutable cmat 1x2202 over GF(2,1)>
gap> v := ns2[1]*ns;
<immutable cvec over GF(2,1) of length 4370>
gap> setup := OrbitBySuborbitBootstrapForVectors(
>   [lgens,mgens,bgens],
>   [lgensp,mgensp,[(),()]],
>   [660,95040,Size(ctb)],
>   [20,32],rec());
#I  Calculating stabilizer chain for whole group...
#I  Trying smaller degree permutation representation for U2...
#I  Trying smaller degree permutation representation for U1...
#I  Enumerating permutation base images of U_1...
#I  Looking for U1-coset-recognising U2-orbit in factor space...
#I  OrbitBySuborbit found 100% of a U2-orbit of size 95 040
#I  Found 144 suborbits (need 144)
<setup for an orbit-by-suborbit enumeration, k=2>
gap> o := OrbitBySuborbitKnownSize(setup,v,3,3,2,51,13571955000);
#I  OrbitBySuborbit found 100% of a U2-orbit of size 1
#I  OrbitBySuborbit found 100% of a U2-orbit of size 23 760
...
<orbit-by-suborbit size=13571955000 stabsize=306129918735099415756800 (
51%) saving factor=45195>]]>
</Log>

</Section>

<!-- ############################################################ -->

</Chapter>
